/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedClaimRewardsInstruction,
  type ParsedInitializeInstruction,
  type ParsedInitializeRewardsStateInstruction,
  type ParsedUpdateAuthorityInstruction,
  type ParsedUpdateMerkleRootInstruction,
} from '../instructions';

export const DEPHY_REWARDS_PROGRAM_ADDRESS =
  'PHYRvUPmU31VoVgoiK9RRgwtKTnejV5v4QfBvvXXTmV' as Address<'PHYRvUPmU31VoVgoiK9RRgwtKTnejV5v4QfBvvXXTmV'>;

export enum DephyRewardsAccount {
  ClaimState,
  GlobalConfig,
  RewardsState,
}

export function identifyDephyRewardsAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): DephyRewardsAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([71, 73, 19, 83, 53, 228, 242, 53])
      ),
      0
    )
  ) {
    return DephyRewardsAccount.ClaimState;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([149, 8, 156, 202, 160, 252, 176, 217])
      ),
      0
    )
  ) {
    return DephyRewardsAccount.GlobalConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([155, 23, 165, 17, 31, 127, 88, 135])
      ),
      0
    )
  ) {
    return DephyRewardsAccount.RewardsState;
  }
  throw new Error(
    'The provided account could not be identified as a dephyRewards account.'
  );
}

export enum DephyRewardsInstruction {
  ClaimRewards,
  Initialize,
  InitializeRewardsState,
  UpdateAuthority,
  UpdateMerkleRoot,
}

export function identifyDephyRewardsInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): DephyRewardsInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([4, 144, 132, 71, 116, 23, 151, 80])
      ),
      0
    )
  ) {
    return DephyRewardsInstruction.ClaimRewards;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
      ),
      0
    )
  ) {
    return DephyRewardsInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([185, 222, 190, 230, 192, 41, 93, 51])
      ),
      0
    )
  ) {
    return DephyRewardsInstruction.InitializeRewardsState;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([32, 46, 64, 28, 149, 75, 243, 88])
      ),
      0
    )
  ) {
    return DephyRewardsInstruction.UpdateAuthority;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([195, 173, 38, 60, 242, 203, 158, 93])
      ),
      0
    )
  ) {
    return DephyRewardsInstruction.UpdateMerkleRoot;
  }
  throw new Error(
    'The provided instruction could not be identified as a dephyRewards instruction.'
  );
}

export type ParsedDephyRewardsInstruction<
  TProgram extends string = 'PHYRvUPmU31VoVgoiK9RRgwtKTnejV5v4QfBvvXXTmV',
> =
  | ({
      instructionType: DephyRewardsInstruction.ClaimRewards;
    } & ParsedClaimRewardsInstruction<TProgram>)
  | ({
      instructionType: DephyRewardsInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: DephyRewardsInstruction.InitializeRewardsState;
    } & ParsedInitializeRewardsStateInstruction<TProgram>)
  | ({
      instructionType: DephyRewardsInstruction.UpdateAuthority;
    } & ParsedUpdateAuthorityInstruction<TProgram>)
  | ({
      instructionType: DephyRewardsInstruction.UpdateMerkleRoot;
    } & ParsedUpdateMerkleRootInstruction<TProgram>);
